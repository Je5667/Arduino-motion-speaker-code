#include <Wire.h>
#include <Arduino.h>
/* Debug */
#define DEBUG                   0
/* APDS-9960 I2C address */
#define APDS9960_I2C_ADDR0x39
/* Gesture parameters */
#define GESTURE_THRESHOLD_OUT   10
#define GESTURE_SENSITIVITY_1   50
#define GESTURE_SENSITIVITY_2   20
/* Error code for returned values */
#define ERROR0xFF
/* Acceptable device IDs */
#define APDS9960_ID_10xAB
#define APDS9960_ID_20x9C
/* Misc parameters */
#define FIFO_PAUSE_TIME         30// Wait period (ms) between FIFO reads
/* APDS-9960 register addresses */
#define APDS9960_ENABLE0x80
#define APDS9960_ATIME0x81
#define APDS9960_WTIME0x83
#define APDS9960_AILTL0x84
#define APDS9960_AILTH0x85
#define APDS9960_AIHTL0x86
#define APDS9960_AIHTH0x87
#define APDS9960_PILT0x89
#define APDS9960_PIHT0x8B
#define APDS9960_PERS0x8C
#define APDS9960_CONFIG10x8D
#define APDS9960_PPULSE0x8E
#define APDS9960_CONTROL0x8F
#define APDS9960_CONFIG20x90
#define APDS9960_ID0x92
#define APDS9960_STATUS0x93
#define APDS9960_CDATAL0x94
#define APDS9960_CDATAH0x95
#define APDS9960_RDATAL0x96
#define APDS9960_RDATAH0x97
#define APDS9960_GDATAL0x98
#define APDS9960_GDATAH0x99
#define APDS9960_BDATAL0x9A
#define APDS9960_BDATAH0x9B
#define APDS9960_PDATA0x9C
#define APDS9960_POFFSET_UR0x9D
#define APDS9960_POFFSET_DL0x9E
#define APDS9960_CONFIG30x9F
#define APDS9960_GPENTH0xA0
#define APDS9960_GEXTH0xA1
#define APDS9960_GCONF10xA2
#define APDS9960_GCONF20xA3
#define APDS9960_GOFFSET_U0xA4
#define APDS9960_GOFFSET_D0xA5
#define APDS9960_GOFFSET_L0xA7
#define APDS9960_GOFFSET_R0xA9
#define APDS9960_GPULSE0xA6
#define APDS9960_GCONF30xAA
#define APDS9960_GCONF40xAB
#define APDS9960_GFLVL0xAE
#define APDS9960_GSTATUS0xAF
#define APDS9960_IFORCE0xE4
#define APDS9960_PICLEAR0xE5
#define APDS9960_CICLEAR0xE6
#define APDS9960_AICLEAR0xE7
#define APDS9960_GFIFO_U0xFC
#define APDS9960_GFIFO_D0xFD
#define APDS9960_GFIFO_L0xFE
#define APDS9960_GFIFO_R0xFF
/* Bit fields */
#define APDS9960_PON0b00000001
#define APDS9960_AEN0b00000010
#define APDS9960_PEN0b00000100
#define APDS9960_WEN0b00001000
#define APSD9960_AIEN0b00010000
#define APDS9960_PIEN0b00100000
#define APDS9960_GEN0b01000000
#define APDS9960_GVALID0b00000001
/* On/Off definitions */
#define OFF                     0
#define ON                      1
/* Acceptable parameters for setMode */
#define POWER                   0
#define AMBIENT_LIGHT           1
#define PROXIMITY               2
#define WAIT                    3
#define AMBIENT_LIGHT_INT       4
#define PROXIMITY_INT           5
#define GESTURE                 6
#define ALL                     7
/* Proximity Gain (PGAIN) values */
#define PGAIN_1X                0
#define PGAIN_2X                1
#define PGAIN_4X                2
#define PGAIN_8X                3
/* ALS Gain (AGAIN) values */
#define AGAIN_1X                0
#define AGAIN_4X                1
#define AGAIN_16X               2
#define AGAIN_64X               3
/* Gesture Gain (GGAIN) values */
#define GGAIN_1X                0
#define GGAIN_2X                1
#define GGAIN_4X                2
#define GGAIN_8X                3
/* Gesture wait time values */
#define GWTIME_0MS              0
#define GWTIME_2_8MS            1
#define GWTIME_5_6MS            2
#define GWTIME_8_4MS            3
#define GWTIME_14_0MS           4
#define GWTIME_22_4MS           5
#define GWTIME_30_8MS           6
#define GWTIME_39_2MS           7
/* Default values */
#define DEFAULT_ATIME           219// 103ms
#define DEFAULT_WTIME           246// 27ms
#define DEFAULT_PROX_PPULSE0x87// 16us, 8 pulses
#define DEFAULT_GESTURE_PPULSE0x89// 16us, 10 pulses
#define DEFAULT_POFFSET_UR      0// 0 offset
#define DEFAULT_POFFSET_DL      0// 0 offset      
#define DEFAULT_CONFIG10x60// No 12x wait (WTIME) factor
#define DEFAULT_PGAINPGAIN_4X
#define DEFAULT_AGAINAGAIN_4X
#define DEFAULT_PILT            0// Low proximity threshold
#define DEFAULT_PIHT            50// High proximity threshold
#define DEFAULT_AILT0xFFFF// Force interrupt for calibration
#define DEFAULT_AIHT            0
#define DEFAULT_PERS0x11// 2 consecutive prox or ALS for int.
#define DEFAULT_CONFIG20x01// No saturation interrupts or LED boost  
#define DEFAULT_CONFIG3         0// Enable all photodiodes, no SAI
#define DEFAULT_GPENTH          40// Threshold for entering gesture mode
#define DEFAULT_GEXTH           30// Threshold for exiting gesture mode    
#define DEFAULT_GCONF10x40// 4 gesture events for int., 1 for exit
#define DEFAULT_GGAINGGAIN_1X
#define DEFAULT_GWTIMEGWTIME_2_8MS
#define DEFAULT_GOFFSET         0// No offset scaling for gesture mode
#define DEFAULT_GPULSE0xC9// 32us, 10 pulses
#define DEFAULT_GCONF3          0// All photodiodes active during gesture
#define DEFAULT_GIEN            0// Disable gesture interrupts
/* Direction definitions */
enum {
  NONE,
  LEFT,
  RIGHT,
  UP,
  DOWN,
  NEAR,
  FAR,
  ALLLIST
};
/* State definitions */
enum {
  NAST,
  NEARST,
  FARST,
  ALLST
};
/* Container for gesture data */
typedef structgesturedatatype {
    uint8_t u_data[32];
    uint8_t d_data[32];
    uint8_t l_data[32];
    uint8_t r_data[32];
    uint8_tindex;
    uint8_ttotal_gestures;
    uint8_tin_threshold;
    uint8_tout_threshold;
}gesturedatatype;
/* APDS9960 Class */
classAPDS9960 {
public:
/* Initialization methods */
    APDS9960();
    ~APDS9960();
    bool init();
    uint8_t getMode();
    bool setMode(uint8_t mode, uint8_t enable);
    
/* Turn the APDS-9960 on and off */
    bool enablePower();
    bool disablePower();
    
/* Enable or disable specific sensors */
    bool enableLightSensor(bool interruptsfalse);
    bool disableLightSensor();
    bool enableProximitySensor(bool interruptsfalse);
    bool disableProximitySensor();
    bool enableGestureSensor(bool interruptstrue);
    bool disableGestureSensor();
    
   
/* Gain control */
    uint8_t getAmbientLightGain();
    bool setAmbientLightGain(uint8_t gain);
    uint8_t getProximityGain();
    bool setProximityGain(uint8_t gain);
    uint8_t getGestureGain();
    bool setGestureGain(uint8_t gain);
    
    
/* Get and set proximity interrupt thresholds */
    bool getProximityIntLowThreshold(uint8_t &threshold);
    bool setProximityIntLowThreshold(uint8_t threshold);
    bool getProximityIntHighThreshold(uint8_t &threshold);
    bool setProximityIntHighThreshold(uint8_t threshold);
    
/* Get and set interrupt enables */
    uint8_t getAmbientLightIntEnable();
    bool setAmbientLightIntEnable(uint8_t enable);
    uint8_t getProximityIntEnable();
    bool setProximityIntEnable(uint8_t enable);
    uint8_t getGestureIntEnable();
    bool setGestureIntEnable(uint8_t enable);
    
/* Clear interrupts */
    bool clearAmbientLightInt();
    bool clearProximityInt();
    
     
/* Proximity methods */
    bool readProximity(uint8_t &val);
    
/* Gesture methods */
    bool isGestureAvailable();
    int readGesture();
    
private:
/* Gesture processing */
    void resetGestureParameters();
    bool processGestureData();
    bool decodeGesture();
/* Proximity Interrupt Threshold */
    uint8_t getProxIntLowThresh();
    bool setProxIntLowThresh(uint8_t threshold);
    uint8_t getProxIntHighThresh();
    bool setProxIntHighThresh(uint8_t threshold);
    
 
/* Proximity photodiode select */
    uint8_t getProxGainCompEnable();
    bool setProxGainCompEnable(uint8_t enable);
    uint8_t getProxPhotoMask();
    bool setProxPhotoMask(uint8_t mask);
    
/* Gesture threshold control */
    uint8_t getGestureEnterThresh();
    bool setGestureEnterThresh(uint8_t threshold);
    uint8_t getGestureExitThresh();
    bool setGestureExitThresh(uint8_t threshold);
    
    
/* Gesture mode */
    uint8_t getGestureMode();
    bool setGestureMode(uint8_t mode);
/* Raw I2C Commands */
    bool wireWriteByte(uint8_t val);
    bool wireWriteDataByte(uint8_t reg, uint8_t val);
    bool wireWriteDataBlock(uint8_t reg, uint8_t *val, unsigned int len);
    bool wireReadDataByte(uint8_t reg, uint8_t &val);
    int wireReadDataBlock(uint8_t reg, uint8_t *val, unsigned int len);
/* Members */
gesturedatatype gesture_data_;
    intgesture_ud_delta_;
    intgesture_lr_delta_;
    intgesture_ud_count_;
    intgesture_lr_count_;
    intgesture_near_count_;
    intgesture_far_count_;
    intgesture_state_;
    intgesture_motion_;
};
/**
* @briefConstructor - Instantiates APDS9960 object
*/
APDS9960::APDS9960()
{
gesture_ud_delta_ = 0;
gesture_lr_delta_ = 0;
    
gesture_ud_count_ = 0;
gesture_lr_count_ = 0;
    
gesture_near_count_ = 0;
gesture_far_count_ = 0;
    
gesture_state_ = 0;
gesture_motion_ = NONE;
}
 
/**
* @briefDestructor
*/
APDS9960::~APDS9960()
{
}
/**
* @briefConfigures I2C communications and initializes registers to defaults
*
* @returnTrue if initialized successfully. False otherwise.
*/
boolAPDS9960::init()
{
    uint8_tid;
/* Initialize I2C */
    Wire.begin();
     
/* Read ID register and check against known values for APDS-9960 */
    if(!wireReadDataByte(APDS9960_ID, id)){
        return false;
    }
    if(!(id == APDS9960_ID_1 || id == APDS9960_ID_2)){
        return false;
    }
     
/* Set ENABLE register to 0 (disable all features) */
    if(!setMode(ALL, OFF)){
        return false;
    }
    
/* Set default values for ambient light and proximity registers */
    if(!wireWriteDataByte(APDS9960_ATIME, DEFAULT_ATIME)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_WTIME, DEFAULT_WTIME)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_PPULSE, DEFAULT_PROX_PPULSE)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_POFFSET_UR, DEFAULT_POFFSET_UR)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_POFFSET_DL, DEFAULT_POFFSET_DL)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_CONFIG1, DEFAULT_CONFIG1)){
        return false;
    }
    if(!setProximityGain(DEFAULT_PGAIN)){
        return false;
    }
    if(!setAmbientLightGain(DEFAULT_AGAIN)){
        return false;
    }
    if(!setProxIntLowThresh(DEFAULT_PILT)){
        return false;
    }
    if(!setProxIntHighThresh(DEFAULT_PIHT)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_PERS, DEFAULT_PERS)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_CONFIG2, DEFAULT_CONFIG2)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_CONFIG3, DEFAULT_CONFIG3)){
        return false;
    }
    
/* Set default values for gesture sense registers */
    if(!setGestureEnterThresh(DEFAULT_GPENTH)){
        return false;
    }
    if(!setGestureExitThresh(DEFAULT_GEXTH)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_GCONF1, DEFAULT_GCONF1)){
        return false;
    }
    if(!setGestureGain(DEFAULT_GGAIN)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_GOFFSET_U, DEFAULT_GOFFSET)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_GOFFSET_D, DEFAULT_GOFFSET)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_GOFFSET_L, DEFAULT_GOFFSET)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_GOFFSET_R, DEFAULT_GOFFSET)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_GPULSE, DEFAULT_GPULSE)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_GCONF3, DEFAULT_GCONF3)){
        return false;
    }
    if(!setGestureIntEnable(DEFAULT_GIEN)){
        return false;
    }
    
#if 0
/* Gesture config register dump */
    uint8_treg;
    uint8_tval;
  
    for(reg = 0x80; reg <= 0xAF; reg++){
        if((reg != 0x82) && \
            (reg != 0x8A) && \
            (reg != 0x91) && \
            (reg != 0xA8) && \
            (reg != 0xAC) && \
            (reg != 0xAD))
        {
            wireReadDataByte(reg, val);
            Serial.print(reg, HEX);
            Serial.print(": 0x");
            Serial.println(val, HEX);
        }
    }
    for(reg = 0xE4; reg <= 0xE7; reg++){
        wireReadDataByte(reg, val);
        Serial.print(reg, HEX);
        Serial.print(": 0x");
        Serial.println(val, HEX);
    }
#endif
    return true;
}
/*******************************************************************************
* Public methods for controlling the APDS-9960
******************************************************************************/
/**
* @briefReads and returns the contents of the ENABLE register
*
* @returnContents of the ENABLE register. 0xFF if error.
*/
uint8_tAPDS9960::getMode()
{
    uint8_tenable_value;
    
/* Read current ENABLE register */
    if(!wireReadDataByte(APDS9960_ENABLE, enable_value)){
        returnERROR;
    }
    
    returnenable_value;
}
/**
* @briefEnables or disables a feature in the APDS-9960
*
* @param[in] modewhich feature to enable
* @param[in] enableON (1) or OFF (0)
* @returnTrue if operation success. False otherwise.
*/
boolAPDS9960::setMode(uint8_t mode, uint8_t enable)
{
    uint8_treg_val;
/* Read current ENABLE register */
reg_val = getMode();
    if(reg_val == ERROR ){
        return false;
    }
    
/* Change bit(s) in ENABLE register */
enable = enable & 0x01;
    if(mode >= 0&& mode <= 6 ){
        if (enable){
reg_val |= (1<< mode);
        }else {
reg_val &= ~(1<< mode);
        }
    }else if(mode == ALL ){
        if (enable){
reg_val = 0x7F;
        }else {
reg_val = 0x00;
        }
    }
        
/* Write value back to ENABLE register */
    if(!wireWriteDataByte(APDS9960_ENABLE, reg_val)){
        return false;
    }
        
    return true;
}
/**
* @briefStarts the light (R/G/B/Ambient) sensor on the APDS-9960
*
* @param[in] interruptstrue to enable hardware interrupt on high or low light
* @returnTrue if sensor enabled correctly. False on error.
*/
boolAPDS9960::enableLightSensor(bool interrupts)
{
    
/* Set default gain, interrupts, enable power, and enable sensor */
    if(!setAmbientLightGain(DEFAULT_AGAIN)){
        return false;
    }
    if(interrupts ){
        if(!setAmbientLightIntEnable(1)){
            return false;
        }
    }else {
        if(!setAmbientLightIntEnable(0)){
            return false;
        }
    }
    if(!enablePower()){
        return false;
    }
    if(!setMode(AMBIENT_LIGHT, 1)){
        return false;
    }
    
    return true;
}
/**
* @briefEnds the light sensor on the APDS-9960
*
* @returnTrue if sensor disabled correctly. False on error.
*/
boolAPDS9960::disableLightSensor()
{
    if(!setAmbientLightIntEnable(0)){
        return false;
    }
    if(!setMode(AMBIENT_LIGHT, 0)){
        return false;
    }
    
    return true;
}
/**
* @briefStarts the proximity sensor on the APDS-9960
*
* @param[in] interruptstrue to enable hardware external interrupt on proximity
* @returnTrue if sensor enabled correctly. False on error.
*/
boolAPDS9960::enableProximitySensor(bool interrupts)
{
/* Set default gain, LED, interrupts, enable power, and enable sensor */
    if(!setProximityGain(DEFAULT_PGAIN)){
        return false;
    }
    if(interrupts ){
        if(!setProximityIntEnable(1)){
            return false;
        }
    }else {
        if(!setProximityIntEnable(0)){
            return false;
        }
    }
    if(!enablePower()){
        return false;
    }
    if(!setMode(PROXIMITY, 1)){
        return false;
    }
    
    return true;
}
/**
* @briefEnds the proximity sensor on the APDS-9960
*
* @returnTrue if sensor disabled correctly. False on error.
*/
boolAPDS9960::disableProximitySensor()
{
  if(!setProximityIntEnable(0)){
    return false;
  }
  if(!setMode(PROXIMITY, 0)){
    return false;
  }
  return true;
}
/**
* @briefStarts the gesture recognition engine on the APDS-9960
*
* @param[in] interruptstrue to enable hardware external interrupt on gesture
* @returnTrue if engine enabled correctly. False on error.
*/
boolAPDS9960::enableGestureSensor(bool interrupts)
{
    
/* Enable gesture mode
Set ENABLE to 0 (power off)
Set WTIME to 0xFF
Set AUX to LED_BOOST_300
Enable PON, WEN, PEN, GEN in ENABLE 
    resetGestureParameters();
    if(!wireWriteDataByte(APDS9960_WTIME, 0xFF)){
        return false;
    }
    if(!wireWriteDataByte(APDS9960_PPULSE, DEFAULT_GESTURE_PPULSE)){
        return false;
    }
    if(interrupts ){
        if(!setGestureIntEnable(1)){
            return false;
        }
    }else {
        if(!setGestureIntEnable(0)){
            return false;
        }
    }
    if(!setGestureMode(1)){
        return false;
    }
    if(!enablePower()){
        return false;
    }
    if(!setMode(WAIT, 1)){
        return false;
    }
    if(!setMode(PROXIMITY, 1)){
        return false;
    }
    if(!setMode(GESTURE, 1)){
        return false;
    }
    
    return true;
}
/**
* @briefEnds the gesture recognition engine on the APDS-9960
*
* @returnTrue if engine disabled correctly. False on error.
*/
boolAPDS9960::disableGestureSensor()
{
    resetGestureParameters();
    if(!setGestureIntEnable(0)){
        return false;
    }
    if(!setGestureMode(0)){
        return false;
    }
    if(!setMode(GESTURE, 0)){
        return false;
    }
    
    return true;
}
/**
* @briefDetermines if there is a gesture available for reading
*
* @returnTrue if gesture available. False otherwise.
*/
boolAPDS9960::isGestureAvailable()
{
    uint8_tval;
    
/* Read value from GSTATUS register */
    if(!wireReadDataByte(APDS9960_GSTATUS, val)){
        returnERROR;
    }
    
/* Shift and mask out GVALID bit */
val &= APDS9960_GVALID;
    
/* Return true/false based on GVALID bit */
    if(val == 1){
        return true;
    }else {
        return false;
    }
}
/**
* @briefProcesses a gesture event and returns best guessed gesture
*
* @returnNumber corresponding to gesture. -1 on error.
*/
intAPDS9960::readGesture()
{
    uint8_tfifo_level = 0;
    uint8_tbytes_read = 0;
    uint8_t fifo_data[128];
    uint8_tgstatus;
    intmotion;
    inti;
    
/* Make sure that power and gesture is on and data is valid */
    if(!isGestureAvailable()|| !(getMode()& 0b01000001)){
        returnNONE;
    }
    
/* Keep looping as long as gesture data is valid */
    while(1){
    
/* Wait some time to collect next batch of FIFO data */
        delay(FIFO_PAUSE_TIME);
        
/* Get the contents of the STATUS register. Is data still valid? */
        if(!wireReadDataByte(APDS9960_GSTATUS, gstatus)){
            returnERROR;
        }
        
/* If we have valid data, read in FIFO */
        if((gstatus & APDS9960_GVALID)== APDS9960_GVALID ){
        
/* Read the current FIFO level */
            if(!wireReadDataByte(APDS9960_GFLVL, fifo_level)){
                returnERROR;
            }
#if DEBUG
            Serial.print("FIFO Level: ");
            Serial.println(fifo_level);
#endif
/* If there's stuff in the FIFO, read it into our data block */
            if(fifo_level > 0){
bytes_read = wireReadDataBlock(APDS9960_GFIFO_U, 
                                                (uint8_t*)fifo_data, 
                                                (fifo_level * 4));
                if(bytes_read == -1 ){
                    returnERROR;
                }
#if DEBUG
                Serial.print("FIFO Dump: ");
                for (i = 0; i < bytes_read; i++ ){
                    Serial.print(fifo_data[i]);
                    Serial.print(" ");
                }
                Serial.println();
#endif
/* If at least 1 set of data, sort the data into U/D/L/R */
                if(bytes_read >= 4 ){
                    for(i = 0; i < bytes_read; i += 4 ){
                        gesture_data_.u_data[gesture_data_.index] = \
                                                            fifo_data[i + 0];
                        gesture_data_.d_data[gesture_data_.index] = \
                                                            fifo_data[i + 1];
                        gesture_data_.l_data[gesture_data_.index] = \
                                                            fifo_data[i + 2];
                        gesture_data_.r_data[gesture_data_.index] = \
                                                            fifo_data[i + 3];
                        gesture_data_.index++;
                        gesture_data_.total_gestures++;
                    }
                    
#if DEBUG
                Serial.print("Up Data: ");
                for (i = 0; i < gesture_data_.total_gestures; i++ ){
                    Serial.print(gesture_data_.u_data[i]);
                    Serial.print(" ");
                }
                Serial.println();
#endif
/* Filter and process gesture data. Decode near/far state */
                    if(processGestureData()){
                        if(decodeGesture()){
//***TODO: U-Turn Gestures
#if DEBUG
//Serial.println(gesture_motion_);
#endif
                        }
}
                    
/* Reset data */
                    gesture_data_.index0;
                    gesture_data_.total_gestures0;
}
}
} else {
    
/* Determine best guessed gesture and clean up */
            delay(FIFO_PAUSE_TIME);
            decodeGesture();
motion = gesture_motion_;
#if DEBUG
            Serial.print("END: ");
            Serial.println(gesture_motion_);
#endif
            resetGestureParameters();
            returnmotion;
}
}
}
/**
* Turn the APDS-9960 on
*
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::enablePower()
{
    if(!setMode(POWER, 1)){
        return false;
    }
    
    return true;
}
/**
* Turn the APDS-9960 off
*
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::disablePower()
{
    if(!setMode(POWER, 0)){
        return false;
    }
    
    return true;
}

/*******************************************************************************
* Proximity sensor controls
******************************************************************************/
/**
* @briefReads the proximity level as an 8-bit value
*
* @param[out] valvalue of the proximity sensor.
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::readProximity(uint8_t &val)
{
val = 0;
    
/* Read value from proximity data register */
    if(!wireReadDataByte(APDS9960_PDATA, val)){
        return false;
    }
    
    return true;
}
/*******************************************************************************
* High-level gesture controls
******************************************************************************/
/**
* @briefResets all the parameters in the gesture data member
*/
voidAPDS9960::resetGestureParameters()
{
    gesture_data_.index0;
    gesture_data_.total_gestures0;
    
gesture_ud_delta_ = 0;
gesture_lr_delta_ = 0;
    
gesture_ud_count_ = 0;
gesture_lr_count_ = 0;
    
gesture_near_count_ = 0;
gesture_far_count_ = 0;
    
gesture_state_ = 0;
gesture_motion_ = NONE;
}
/**
* @briefProcesses the raw gesture data to determine swipe direction
*
* @returnTrue if near or far state seen. False otherwise.
*/
boolAPDS9960::processGestureData()
{
    uint8_tu_first = 0;
    uint8_td_first = 0;
    uint8_tl_first = 0;
    uint8_tr_first = 0;
    uint8_tu_last = 0;
    uint8_td_last = 0;
    uint8_tl_last = 0;
    uint8_tr_last = 0;
    intud_ratio_first;
    intlr_ratio_first;
    intud_ratio_last;
    intlr_ratio_last;
    intud_delta;
    intlr_delta;
    inti;
/* If we have less than 4 total gestures, that's not enough */
    if(gesture_data_.total_gestures<= 4 ){
        return false;
    }
    
/* Check to make sure our data isn't out of bounds */
    if((gesture_data_.total_gestures<= 32) && \
        (gesture_data_.total_gestures > 0)){
        
/* Find the first value in U/D/L/R above the threshold */
        for(i = 0; i < gesture_data_.total_gestures; i++ ){
            if((gesture_data_.u_data[i] > GESTURE_THRESHOLD_OUT) &&
                (gesture_data_.d_data[i] > GESTURE_THRESHOLD_OUT) &&
                (gesture_data_.l_data[i] > GESTURE_THRESHOLD_OUT) &&
                (gesture_data_.r_data[i] > GESTURE_THRESHOLD_OUT)){
                
gesture_data_.u_data[i];
gesture_data_.d_data[i];
gesture_data_.l_data[i];
gesture_data_.r_data[i];
                break;
            }
        }
        
/* If one of the _first values is 0, then there is no good data */
        if((u_first == 0)|| (d_first == 0)|| \
            (l_first == 0)|| (r_first == 0)){
            
            return false;
        }
/* Find the last value in U/D/L/R above the threshold */
        for(i = gesture_data_.total_gestures1; i >= 0; i-- ){
#if DEBUG
            Serial.print(F("Finding last: "));
            Serial.print(F("U:"));
            Serial.print(gesture_data_.u_data[i]);
            Serial.print(F(" D:"));
            Serial.print(gesture_data_.d_data[i]);
            Serial.print(F(" L:"));
            Serial.print(gesture_data_.l_data[i]);
            Serial.print(F(" R:"));
            Serial.println(gesture_data_.r_data[i]);
#endif
            if((gesture_data_.u_data[i] > GESTURE_THRESHOLD_OUT) &&
                (gesture_data_.d_data[i] > GESTURE_THRESHOLD_OUT) &&
                (gesture_data_.l_data[i] > GESTURE_THRESHOLD_OUT) &&
                (gesture_data_.r_data[i] > GESTURE_THRESHOLD_OUT)){
                
u_last = gesture_data_.u_data[i];
d_last = gesture_data_.d_data[i];
l_last = gesture_data_.l_data[i];
r_last = gesture_data_.r_data[i];
                break;
            }
        }
}
    
/* Calculate the first vs. last ratio of up/down and left/right */
ud_ratio_first = ((u_first - d_first)100)(u_first + d_first);
lr_ratio_first = ((l_first - r_first)100)(l_first + r_first);
ud_ratio_last = ((u_last - d_last)100)(u_last + d_last);
lr_ratio_last = ((l_last - r_last)100)(l_last + r_last);
       
#if DEBUG
    Serial.print(F("Last Values: "));
    Serial.print(F("U:"));
    Serial.print(u_last);
    Serial.print(F(" D:"));
    Serial.print(d_last);
    Serial.print(F(" L:"));
    Serial.print(l_last);
    Serial.print(F(" R:"));
    Serial.println(r_last);
    Serial.print(F("Ratios: "));
    Serial.print(F("UD Fi: "));
    Serial.print(ud_ratio_first);
    Serial.print(F(" UD La: "));
    Serial.print(ud_ratio_last);
    Serial.print(F(" LR Fi: "));
    Serial.print(lr_ratio_first);
    Serial.print(F(" LR La: "));
    Serial.println(lr_ratio_last);
#endif
       
/* Determine the difference between the first and last ratios */
ud_delta = ud_ratio_last - ud_ratio_first;
lr_delta = lr_ratio_last - lr_ratio_first;
    
#if DEBUG
    Serial.print("Deltas: ");
    Serial.print("UD: ");
    Serial.print(ud_delta);
    Serial.print(" LR: ");
    Serial.println(lr_delta);
#endif
/* Accumulate the UD and LR delta values */
gesture_ud_delta_ += ud_delta;
gesture_lr_delta_ += lr_delta;
    
#if DEBUG
    Serial.print("Accumulations: ");
    Serial.print("UD: ");
    Serial.print(gesture_ud_delta_);
    Serial.print(" LR: ");
    Serial.println(gesture_lr_delta_);
#endif
    
/* Determine U/D gesture */
    if(gesture_ud_delta_ >= GESTURE_SENSITIVITY_1 ){
gesture_ud_count_ = 1;
    }else if(gesture_ud_delta_ <= -GESTURE_SENSITIVITY_1 ){
gesture_ud_count_ = -1;
    }else {
gesture_ud_count_ = 0;
    }
    
/* Determine L/R gesture */
    if(gesture_lr_delta_ >= GESTURE_SENSITIVITY_1 ){
gesture_lr_count_ = 1;
    }else if(gesture_lr_delta_ <= -GESTURE_SENSITIVITY_1 ){
gesture_lr_count_ = -1;
    }else {
gesture_lr_count_ = 0;
    }
    
/* Determine Near/Far gesture */
    if((gesture_ud_count_ == 0) && (gesture_lr_count_ == 0)){
        if((abs(ud_delta)< GESTURE_SENSITIVITY_2) && \
            (abs(lr_delta)< GESTURE_SENSITIVITY_2)){
            
            if((ud_delta == 0) && (lr_delta == 0)){
gesture_near_count_++;
            }else if((ud_delta != 0)|| (lr_delta != 0)){
gesture_far_count_++;
            }
            
            if((gesture_near_count_ >= 10) && (gesture_far_count_ >= 2)){
                if((ud_delta == 0) && (lr_delta == 0)){
gesture_state_ = NEARST;
                }else if((ud_delta != 0) && (lr_delta != 0)){
gesture_state_ = FARST;
                }
                return true;
            }
        }
    }else {
        if((abs(ud_delta)< GESTURE_SENSITIVITY_2) && \
            (abs(lr_delta)< GESTURE_SENSITIVITY_2)){
                
            if((ud_delta == 0) && (lr_delta == 0)){
gesture_near_count_++;
            }
            
            if(gesture_near_count_ >= 10 ){
gesture_ud_count_ = 0;
gesture_lr_count_ = 0;
gesture_ud_delta_ = 0;
gesture_lr_delta_ = 0;
            }
        }
    }
    
#if DEBUG
    Serial.print("UD_CT: ");
    Serial.print(gesture_ud_count_);
    Serial.print(" LR_CT: ");
    Serial.print(gesture_lr_count_);
    Serial.print(" NEAR_CT: ");
    Serial.print(gesture_near_count_);
    Serial.print(" FAR_CT: ");
    Serial.println(gesture_far_count_);
    Serial.println("----------");
#endif
    
    return false;
}
/**
* @briefDetermines swipe direction or near/far state
*
* @returnTrue if near/far event. False otherwise.
*/
boolAPDS9960::decodeGesture()
{
/* Return if near or far event is detected */
    if(gesture_state_ == NEARST ){
gesture_motion_ = NEAR;
        return true;
    }else if (gesture_state_ == FARST ){
gesture_motion_ = FAR;
        return true;
    }
    
/* Determine swipe direction */
    if((gesture_ud_count_ == -1) && (gesture_lr_count_ == 0)){
gesture_motion_ = UP;
    }else if((gesture_ud_count_ == 1) && (gesture_lr_count_ == 0)){
gesture_motion_ = DOWN;
    }else if((gesture_ud_count_ == 0) && (gesture_lr_count_ == 1)){
gesture_motion_ = RIGHT;
    }else if((gesture_ud_count_ == 0) && (gesture_lr_count_ == -1)){
gesture_motion_ = LEFT;
    }else if((gesture_ud_count_ == -1) && (gesture_lr_count_ == 1)){
        if(abs(gesture_ud_delta_) > abs(gesture_lr_delta_)){
gesture_motion_ = UP;
        }else {
gesture_motion_ = RIGHT;
        }
    }else if((gesture_ud_count_ == 1) && (gesture_lr_count_ == -1)){
        if(abs(gesture_ud_delta_) > abs(gesture_lr_delta_)){
gesture_motion_ = DOWN;
        }else {
gesture_motion_ = LEFT;
        }
    }else if((gesture_ud_count_ == -1) && (gesture_lr_count_ == -1)){
        if(abs(gesture_ud_delta_) > abs(gesture_lr_delta_)){
gesture_motion_ = UP;
        }else {
gesture_motion_ = LEFT;
        }
    }else if((gesture_ud_count_ == 1) && (gesture_lr_count_ == 1)){
        if(abs(gesture_ud_delta_) > abs(gesture_lr_delta_)){
gesture_motion_ = DOWN;
        }else {
gesture_motion_ = RIGHT;
        }
    }else {
        return false;
    }
    
    return true;
}
/*******************************************************************************
* Getters and setters for register values
******************************************************************************/
/**
* @briefReturns the lower threshold for proximity detection
*
* @returnlower threshold
*/
uint8_tAPDS9960::getProxIntLowThresh()
{
    uint8_tval;
    
/* Read value from PILT register */
    if(!wireReadDataByte(APDS9960_PILT, val)){
0;
    }
    
    returnval;
}
/**
* @briefSets the lower threshold for proximity detection
*
* @param[in] thresholdthe lower proximity threshold
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setProxIntLowThresh(uint8_t threshold)
{
    if(!wireWriteDataByte(APDS9960_PILT, threshold)){
        return false;
    }
    
    return true;
}
/**
* @briefReturns the high threshold for proximity detection
*
* @returnhigh threshold
*/
uint8_tAPDS9960::getProxIntHighThresh()
{
    uint8_tval;
    
/* Read value from PIHT register */
    if(!wireReadDataByte(APDS9960_PIHT, val)){
0;
    }
    
    returnval;
}
/**
* @briefSets the high threshold for proximity detection
*
* @param[in] thresholdthe high proximity threshold
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setProxIntHighThresh(uint8_t threshold)
{
    if(!wireWriteDataByte(APDS9960_PIHT, threshold)){
        return false;
    }
    
    return true;
}

/**
* @briefReturns receiver gain for proximity detection
*
* Value    Gain
*   0       1x
*   1       2x
*   2       4x
*   3       8x
*
* @returnthe value of the proximity gain. 0xFF on failure.
*/
uint8_tAPDS9960::getProximityGain()
{
    uint8_tval;
    
/* Read value from CONTROL register */
    if(!wireReadDataByte(APDS9960_CONTROL, val)){
        returnERROR;
    }
    
/* Shift and mask out PDRIVE bits */
val = (val >> 2)& 0b00000011;
    
    returnval;
}
/**
* @briefSets the receiver gain for proximity detection
*
* Value    Gain
*   0       1x
*   1       2x
*   2       4x
*   3       8x
*
* @param[in] drivethe value (0-3) for the gain
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setProximityGain(uint8_t drive)
{
    uint8_tval;
    
/* Read value from CONTROL register */
    if(!wireReadDataByte(APDS9960_CONTROL, val)){
        return false;
    }
    
/* Set bits in register to given value */
drive &= 0b00000011;
drive = drive << 2;
val &= 0b11110011;
val |= drive;
    
/* Write register value back into CONTROL register */
    if(!wireWriteDataByte(APDS9960_CONTROL, val)){
        return false;
    }
    
    return true;
}
/**
* @briefReturns receiver gain for the ambient light sensor (ALS)
*
* Value    Gain
*   0        1x
*   1        4x
*   2       16x
*   3       64x
*
* @returnthe value of the ALS gain. 0xFF on failure.
*/
uint8_tAPDS9960::getAmbientLightGain()
{
    uint8_tval;
    
/* Read value from CONTROL register */
    if(!wireReadDataByte(APDS9960_CONTROL, val)){
        returnERROR;
    }
    
/* Shift and mask out ADRIVE bits */
val &= 0b00000011;
    
    returnval;
}
/**
* @briefSets the receiver gain for the ambient light sensor (ALS)
*
* Value    Gain
*   0        1x
*   1        4x
*   2       16x
*   3       64x
*
* @param[in] drivethe value (0-3) for the gain
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setAmbientLightGain(uint8_t drive)
{
    uint8_tval;
    
/* Read value from CONTROL register */
    if(!wireReadDataByte(APDS9960_CONTROL, val)){
        return false;
    }
    
/* Set bits in register to given value */
drive &= 0b00000011;
val &= 0b11111100;
val |= drive;
    
/* Write register value back into CONTROL register */
    if(!wireWriteDataByte(APDS9960_CONTROL, val)){
        return false;
    }
    
    return true;
}

/**
* @briefGets proximity gain compensation enable
*
* @return1 if compensation is enabled. 0 if not. 0xFF on error.
*/
uint8_tAPDS9960::getProxGainCompEnable()
{
    uint8_tval;
    
/* Read value from CONFIG3 register */
    if(!wireReadDataByte(APDS9960_CONFIG3, val)){
        returnERROR;
    }
    
/* Shift and mask out PCMP bits */
val = (val >> 5)& 0b00000001;
    
    returnval;
}
/**
* @briefSets the proximity gain compensation enable
*
* @param[in] enable1 to enable compensation. 0 to disable compensation.
* @returnTrue if operation successful. False otherwise.
*/
 boolAPDS9960::setProxGainCompEnable(uint8_t enable)
{
    uint8_tval;
    
/* Read value from CONFIG3 register */
    if(!wireReadDataByte(APDS9960_CONFIG3, val)){
        return false;
    }
    
/* Set bits in register to given value */
enable &= 0b00000001;
enable = enable << 5;
val &= 0b11011111;
val |= enable;
    
/* Write register value back into CONFIG3 register */
    if(!wireWriteDataByte(APDS9960_CONFIG3, val)){
        return false;
    }
    
    return true;
}
/**
* @briefGets the current mask for enabled/disabled proximity photodiodes
*
* 1 = disabled, 0 = enabled
* Bit    Photodiode
*  3       UP
*  2       DOWN
*  1       LEFT
*  0       RIGHT
*
* @returnCurrent proximity mask for photodiodes. 0xFF on error.
*/
uint8_tAPDS9960::getProxPhotoMask()
{
    uint8_tval;
    
/* Read value from CONFIG3 register */
    if(!wireReadDataByte(APDS9960_CONFIG3, val)){
        returnERROR;
    }
    
/* Mask out photodiode enable mask bits */
val &= 0b00001111;
    
    returnval;
}
/**
* @briefSets the mask for enabling/disabling proximity photodiodes
*
* 1 = disabled, 0 = enabled
* Bit    Photodiode
*  3       UP
*  2       DOWN
*  1       LEFT
*  0       RIGHT
*
* @param[in] mask4-bit mask value
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setProxPhotoMask(uint8_t mask)
{
    uint8_tval;
    
/* Read value from CONFIG3 register */
    if(!wireReadDataByte(APDS9960_CONFIG3, val)){
        return false;
    }
    
/* Set bits in register to given value */
mask &= 0b00001111;
val &= 0b11110000;
val |= mask;
    
/* Write register value back into CONFIG3 register */
    if(!wireWriteDataByte(APDS9960_CONFIG3, val)){
        return false;
    }
    
    return true;
}
/**
* @briefGets the entry proximity threshold for gesture sensing
*
* @returnCurrent entry proximity threshold.
*/
uint8_tAPDS9960::getGestureEnterThresh()
{
    uint8_tval;
    
/* Read value from GPENTH register */
    if(!wireReadDataByte(APDS9960_GPENTH, val)){
0;
    }
    
    returnval;
}
/**
* @briefSets the entry proximity threshold for gesture sensing
*
* @param[in] thresholdproximity value needed to start gesture mode
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setGestureEnterThresh(uint8_t threshold)
{
    if(!wireWriteDataByte(APDS9960_GPENTH, threshold)){
        return false;
    }
    
    return true;
}
/**
* @briefGets the exit proximity threshold for gesture sensing
*
* @returnCurrent exit proximity threshold.
*/
uint8_tAPDS9960::getGestureExitThresh()
{
    uint8_tval;
    
/* Read value from GEXTH register */
    if(!wireReadDataByte(APDS9960_GEXTH, val)){
0;
    }
    
    returnval;
}
/**
* @briefSets the exit proximity threshold for gesture sensing
*
* @param[in] thresholdproximity value needed to end gesture mode
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setGestureExitThresh(uint8_t threshold)
{
    if(!wireWriteDataByte(APDS9960_GEXTH, threshold)){
        return false;
    }
    
    return true;
}
/**
* @briefGets the gain of the photodiode during gesture mode
*
* Value    Gain
*   0       1x
*   1       2x
*   2       4x
*   3       8x
*
* @returnthe current photodiode gain. 0xFF on error.
*/
uint8_tAPDS9960::getGestureGain()
{
    uint8_tval;
    
/* Read value from GCONF2 register */
    if(!wireReadDataByte(APDS9960_GCONF2, val)){
        returnERROR;
    }
    
/* Shift and mask out GGAIN bits */
val = (val >> 5)& 0b00000011;
    
    returnval;
}
/**
* @briefSets the gain of the photodiode during gesture mode
*
* Value    Gain
*   0       1x
*   1       2x
*   2       4x
*   3       8x
*
* @param[in] gainthe value for the photodiode gain
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setGestureGain(uint8_t gain)
{
    uint8_tval;
    
/* Read value from GCONF2 register */
    if(!wireReadDataByte(APDS9960_GCONF2, val)){
        return false;
    }
    
/* Set bits in register to given value */
gain &= 0b00000011;
gain = gain << 5;
val &= 0b10011111;
val |= gain;
    
/* Write register value back into GCONF2 register */
    if(!wireWriteDataByte(APDS9960_GCONF2, val)){
        return false;
    }
    
    return true;
}
/**
* @briefGets the low threshold for proximity interrupts
*
* @param[out] thresholdcurrent low threshold stored on the APDS-9960
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::getProximityIntLowThreshold(uint8_t &threshold)
{
threshold = 0;
    
/* Read value from proximity low threshold register */
    if(!wireReadDataByte(APDS9960_PILT, threshold)){
        return false;
    }
    
    return true;
}
/**
* @briefSets the low threshold for proximity interrupts
*
* @param[in] thresholdlow threshold value for interrupt to trigger
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setProximityIntLowThreshold(uint8_t threshold)
{
    
/* Write threshold value to register */
    if(!wireWriteDataByte(APDS9960_PILT, threshold)){
        return false;
    }
    
    return true;
}
    
/**
* @briefGets the high threshold for proximity interrupts
*
* @param[out] thresholdcurrent low threshold stored on the APDS-9960
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::getProximityIntHighThreshold(uint8_t &threshold)
{
threshold = 0;
    
/* Read value from proximity low threshold register */
    if(!wireReadDataByte(APDS9960_PIHT, threshold)){
        return false;
    }
    
    return true;
}
/**
* @briefSets the high threshold for proximity interrupts
*
* @param[in] thresholdhigh threshold value for interrupt to trigger
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setProximityIntHighThreshold(uint8_t threshold)
{
    
/* Write threshold value to register */
    if(!wireWriteDataByte(APDS9960_PIHT, threshold)){
        return false;
    }
    
    return true;
}
/**
* @briefGets if ambient light interrupts are enabled or not
*
* @return1 if interrupts are enabled, 0 if not. 0xFF on error.
*/
uint8_tAPDS9960::getAmbientLightIntEnable()
{
    uint8_tval;
    
/* Read value from ENABLE register */
    if(!wireReadDataByte(APDS9960_ENABLE, val)){
        returnERROR;
    }
    
/* Shift and mask out AIEN bit */
val = (val >> 4)& 0b00000001;
    
    returnval;
}
/**
* @briefTurns ambient light interrupts on or off
*
* @param[in] enable1 to enable interrupts, 0 to turn them off
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setAmbientLightIntEnable(uint8_t enable)
{
    uint8_tval;
    
/* Read value from ENABLE register */
    if(!wireReadDataByte(APDS9960_ENABLE, val)){
        return false;
    }
    
/* Set bits in register to given value */
enable &= 0b00000001;
enable = enable << 4;
val &= 0b11101111;
val |= enable;
    
/* Write register value back into ENABLE register */
    if(!wireWriteDataByte(APDS9960_ENABLE, val)){
        return false;
    }
    
    return true;
}
/**
* @briefGets if proximity interrupts are enabled or not
*
* @return1 if interrupts are enabled, 0 if not. 0xFF on error.
*/
uint8_tAPDS9960::getProximityIntEnable()
{
    uint8_tval;
    
/* Read value from ENABLE register */
    if(!wireReadDataByte(APDS9960_ENABLE, val)){
        returnERROR;
    }
    
/* Shift and mask out PIEN bit */
val = (val >> 5)& 0b00000001;
    
    returnval;
}
/**
* @briefTurns proximity interrupts on or off
*
* @param[in] enable1 to enable interrupts, 0 to turn them off
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setProximityIntEnable(uint8_t enable)
{
    uint8_tval;
    
/* Read value from ENABLE register */
    if(!wireReadDataByte(APDS9960_ENABLE, val)){
        return false;
    }
    
/* Set bits in register to given value */
enable &= 0b00000001;
enable = enable << 5;
val &= 0b11011111;
val |= enable;
    
/* Write register value back into ENABLE register */
    if(!wireWriteDataByte(APDS9960_ENABLE, val)){
        return false;
    }
    
    return true;
}
/**
* @briefGets if gesture interrupts are enabled or not
*
* @return1 if interrupts are enabled, 0 if not. 0xFF on error.
*/
uint8_tAPDS9960::getGestureIntEnable()
{
    uint8_tval;
    
/* Read value from GCONF4 register */
    if(!wireReadDataByte(APDS9960_GCONF4, val)){
        returnERROR;
    }
    
/* Shift and mask out GIEN bit */
val = (val >> 1)& 0b00000001;
    
    returnval;
}
/**
* @briefTurns gesture-related interrupts on or off
*
* @param[in] enable1 to enable interrupts, 0 to turn them off
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setGestureIntEnable(uint8_t enable)
{
    uint8_tval;
    
/* Read value from GCONF4 register */
    if(!wireReadDataByte(APDS9960_GCONF4, val)){
        return false;
    }
    
/* Set bits in register to given value */
enable &= 0b00000001;
enable = enable << 1;
val &= 0b11111101;
val |= enable;
    
/* Write register value back into GCONF4 register */
    if(!wireWriteDataByte(APDS9960_GCONF4, val)){
        return false;
    }
    
    return true;
}
/**
* @briefClears the ambient light interrupt
*
* @returnTrue if operation completed successfully. False otherwise.
*/
boolAPDS9960::clearAmbientLightInt()
{
    uint8_tthrowaway;
    if(!wireReadDataByte(APDS9960_AICLEAR, throwaway)){
        return false;
    }
    
    return true;
}
/**
* @briefClears the proximity interrupt
*
* @returnTrue if operation completed successfully. False otherwise.
*/
boolAPDS9960::clearProximityInt()
{
    uint8_tthrowaway;
    if(!wireReadDataByte(APDS9960_PICLEAR, throwaway)){
        return false;
    }
    
    return true;
}
/**
* @briefTells if the gesture state machine is currently running
*
* @return1 if gesture state machine is running, 0 if not. 0xFF on error.
*/
uint8_tAPDS9960::getGestureMode()
{
    uint8_tval;
    
/* Read value from GCONF4 register */
    if(!wireReadDataByte(APDS9960_GCONF4, val)){
        returnERROR;
    }
    
/* Mask out GMODE bit */
val &= 0b00000001;
    
    returnval;
}
/**
* @briefTells the state machine to either enter or exit gesture state machine
*
* @param[in] mode1 to enter gesture state machine, 0 to exit.
* @returnTrue if operation successful. False otherwise.
*/
boolAPDS9960::setGestureMode(uint8_t mode)
{
    uint8_tval;
    
/* Read value from GCONF4 register */
    if(!wireReadDataByte(APDS9960_GCONF4, val)){
        return false;
    }
    
/* Set bits in register to given value */
mode &= 0b00000001;
val &= 0b11111110;
val |= mode;
    
/* Write register value back into GCONF4 register */
    if(!wireWriteDataByte(APDS9960_GCONF4, val)){
        return false;
    }
    
    return true;
}
/*******************************************************************************
* Raw I2C Reads and Writes
******************************************************************************/
/**
* @briefWrites a single byte to the I2C device (no register)
*
* @param[in] valthe 1-byte value to write to the I2C device
* @returnTrue if successful write operation. False otherwise.
*/
boolAPDS9960::wireWriteByte(uint8_t val)
{
    Wire.beginTransmission(APDS9960_I2C_ADDR);
    Wire.write(val);
    if(Wire.endTransmission()!= 0 ){
        return false;
    }
    
    return true;
}
/**
* @briefWrites a single byte to the I2C device and specified register
*
* @param[in] regthe register in the I2C device to write to
* @param[in] valthe 1-byte value to write to the I2C device
* @returnTrue if successful write operation. False otherwise.
*/
boolAPDS9960::wireWriteDataByte(uint8_t reg, uint8_t val)
{
    Wire.beginTransmission(APDS9960_I2C_ADDR);
    Wire.write(reg);
    Wire.write(val);
    if(Wire.endTransmission()!= 0 ){
        return false;
    }
    return true;
}
/**
* @briefWrites a block (array) of bytes to the I2C device and register
*
* @param[in] regthe register in the I2C device to write to
* @param[in] valpointer to the beginning of the data byte array
* @param[in] lenthe length (in bytes) of the data to write
* @returnTrue if successful write operation. False otherwise.
*/
boolAPDS9960::wireWriteDataBlock(  uint8_t reg, 
                                        uint8_t *val, 
                                        unsigned int len)
{
    unsigned inti;
    Wire.beginTransmission(APDS9960_I2C_ADDR);
    Wire.write(reg);
    for(i = 0; i < len; i++){
        Wire.beginTransmission(val[i]);
    }
    if(Wire.endTransmission()!= 0 ){
        return false;
    }
    return true;
}
/**
* @briefReads a single byte from the I2C device and specified register
*
* @param[in] regthe register to read from
* @param[out] thevalue returned from the register
* @returnTrue if successful read operation. False otherwise.
*/
boolAPDS9960::wireReadDataByte(uint8_t reg, uint8_t &val)
{
    
/* Indicate which register we want to read from */
    if (!wireWriteByte(reg)){
        return false;
    }
    
/* Read from register */
    Wire.requestFrom(APDS9960_I2C_ADDR, 1);
    while (Wire.available()){
Wire.read();
    }
    return true;
}
/**
* @briefReads a block (array) of bytes from the I2C device and register
*
* @param[in] regthe register to read from
* @param[out] valpointer to the beginning of the data
* @param[in] lennumber of bytes to read
* @returnNumber of bytes read. -1 on read error.
*/
intAPDS9960::wireReadDataBlock(   uint8_t reg, 
                                        uint8_t *val, 
                                        unsigned int len)
{
    unsigned chari = 0;
    
/* Indicate which register we want to read from */
    if (!wireWriteByte(reg)){
        return-1;
    }
    
/* Read block data */
    Wire.requestFrom(APDS9960_I2C_ADDR, len);
    while (Wire.available()){
        if (i >= len){
            return-1;
        }
        val[i] = Wire.read();
    }
    returni;
}
// Pins
#define APDS9960_INT    2// Needs to be an interrupt pin
// Constants
// Global Variables
APDS9960 apds = APDS9960();
intisr_flag = 0;
/*int led1;
int led2;
int led3;
int led4;*/
void setup(){
// Set interrupt pin as input
  pinMode(APDS9960_INT, INPUT);
  pinMode(9, OUTPUT);// play/stop
  pinMode(10, OUTPUT);// vol+/next
  pinMode(11, OUTPUT);// vol-/rev
  
// Initialize Serial port
  Serial.begin(9600);
  Serial.println();
  Serial.println(F("--------------------------------"));
  Serial.println(F("SparkFun APDS-9960 - GestureTest"));
  Serial.println(F("--------------------------------"));
  
// Initialize interrupt service routine
  attachInterrupt(0, interruptRoutine, FALLING);
// Initialize APDS-9960 (configure I2C and initial values)
  if (apds.init()){
    Serial.println(F("APDS-9960 initialization complete"));
  }else {
    Serial.println(F("Something went wrong during APDS-9960 init!"));
  }
  
// Start running the APDS-9960 gesture sensor engine
  if (apds.enableGestureSensor(true)){
    Serial.println(F("Gesture sensor is now running"));
  }else {
    Serial.println(F("Something went wrong during gesture sensor init!"));
  }
}
void loop(){
  if(isr_flag == 1 ){
    detachInterrupt(0);
    handleGesture();
isr_flag = 0;
    attachInterrupt(0, interruptRoutine, FALLING);
  }
}
void interruptRoutine(){
isr_flag = 1;
}
/*DIR_UP : 시작
DIR_DOWN : 정지
DIR_LEFT : 이전 노래
DIR_RIGHT : 다음 노래
DIR_NEAR : 볼륨 줄이기
DIR_FAR : 볼륨 높이기*/
void handleGesture(){
    if (apds.isGestureAvailable()){
    switch (apds.readGesture()){
      caseUP://플레이
        Serial.println("UP");
        digitalWrite(9,HIGH);
        delay(500);
        digitalWrite(9,LOW);
        break;
      caseDOWN://정지
        Serial.println("DOWN");
        digitalWrite(9,HIGH);
        delay(500);
        digitalWrite(9,LOW);
        break;
      caseLEFT://이전 노래
        Serial.println("LEFT");
        digitalWrite(11,HIGH);
        delay(500);
        digitalWrite(11,LOW);
        break;
      caseRIGHT://다음 노래
        Serial.println("RIGHT");
        digitalWrite(10,HIGH);
        delay(500);
        digitalWrite(10,LOW);
        break;
      caseNEAR://볼륨-
        Serial.println("NEAR");
        digitalWrite(11,HIGH);
        delay(2000);
        digitalWrite(11,LOW);
        break;
      caseFAR://볼륨+
        Serial.println("FAR");
        digitalWrite(10,HIGH);
        delay(2000);
        digitalWrite(10,LOW);
        break;
      default:
        Serial.println("NONE");
    }
  }
}
